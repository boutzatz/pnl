
\documentclass[a4paper,11pt,twoside]{article}
\usepackage{a4wide}
\usepackage{t1enc,lmodern}
\usepackage[dvips=true]{hyperref}
\usepackage{textcomp}
\usepackage{verbatim,moreverb,alltt}
\usepackage{makeidx}
\usepackage[dvips]{color}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[strings]{underscore}
\usepackage{amsmath,amsfonts}



%% --------------------------------------------
\hbadness=10000
\emergencystretch=\hsize
\tolerance=9999
\parindent=0pt
%% --------------------------------------------

\newcommand{\R}{{\mathbb R}}
\newcommand{\C}{{\mathbb C}}
\newcommand{\N}{{\mathbb N}}
\newcommand{\ptr}{\textasteriskcentered}

%%\renewcommand{\exp}[1]{\operatorname{e}^{ #1 } }
\newcommand{\cotan}{\operatorname{cotan}}
\newcommand{\cotanh}{\operatorname{cotanh}}
\newcommand{\expp}[1]{\operatorname{e}^{ #1 } }
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\recaco}[1]{\left [ #1 \right ]}
\newcommand{\crochet}[1]{\left \langle #1 \right \rangle}
\newcommand{\acolade}[1]{\left\{ #1 \right\}}
\newcommand{\real}[1]{\operatorname{Re}(#1)}

\makeatletter

% For dvips + ps2pdf generation
\ifx\HCode\undefined%

\def\var#1{{\tt #1}}

\newcommand{\describefun}[3]{%
  \index{#2}\label{#2} {#1~{\bf #2}~(#3)}}

\newcommand{\describemacro}[2]{%
  \index{#1}\label{#1} {{\bf #1}~(#2)}}

\newcommand{\constentry}[2]{%
  \index{#1}\label{#1}{\bf #1} &&  #2 \\ }

\def\refstruct#1{{\color[named]{Red} #1}}
\def\reffun#1{\hyperref[#1]{#1}}
\def\refmacro{\reffun}
\newenvironment{describeconst}{%
  \noindent\begin{tabular}{lp{1cm}l}}{\end{tabular}}
\def\shortdescribe{\unskip\vskip1ex{\color[named]{Blue} Description~}}
\def\sshortdescribe{\unskip\newline\hskip1em {\color[named]{Blue} Description~}}
\def\parameters{\unskip\newline\hskip1em {\color[named]{Blue} Parameters~}}
\def\example{\unskip\newline\hskip1em {\color[named]{Blue} Example~}}

% Html related stuff
\else%

\def\var#1{\HCode{<span class='var'>}#1\HCode{</span>}}

\newcommand{\describefun}[3]{%
\index{#2}\label{#2} {\HCode{<span class='ret'>}#1\HCode{</span>}~{\bf \HCode{<span class='fun'>}#2\HCode{</span>}}~(\HCode{<span class='args'>}#3\HCode{</span>})}}

\newcommand{\describemacro}[2]{%
  \index{#1}\label{#1} {{\bf #1}~(#2)}}

\newcommand{\constentry}[2]{%
  \index{#1}\label{#1}\HCode{<span class='struct'>}#1\HCode{</span>} && #2 \\ }

\def\refstruct#1{\HCode{<span class='struct'>}#1\HCode{</span>}}
\def\reffun#1{\hyperref[#1]{#1}}
\def\refmacro{\reffun}
\newenvironment{describeconst}{%
  \noindent\begin{tabular}{lp{1cm}l}}{\end{tabular}}
\def\shortdescribe{\unskip\vskip1ex{\HCode{<span class='description'>}Description~\HCode{</span>}}}
\def\sshortdescribe{\unskip\newline\hskip1em \HCode{<span class='description'>}Description~\HCode{</span>}}

\fi
\makeatother


\title{Pnl Manual}
\date{\today}
\author{}

\makeindex
\begin{document}
\maketitle
\tableofcontents

\section{What is Pnl}

Pnl is a scientific library written in C and distributed under
the Gnu Lesser General Public License (LGPL). This manual is divided into four
parts.
\begin{itemize}
\item Mathematical functions: complex numbers, special functions, standard
  financial functions for the Black \& Scholes model.
\item Linear algebra : vectors, matrices, hypermatrices, tridiagonal matrices,
  band matrices and the corresponding routines to manipulate them and solve linear systems.
\item Probabilistic functions: random number generators and  cumulative
  distribution functions.
\item Deterministic toolbox : FFT, Laplace inversion, numerical integration, zero searching,
  multivariate polynomial regression, $\dots$
\end{itemize}

\section{A few helpful conventions}

\begin{itemize}
  \item All header file names are prefixed by \verb!pnl_! and are surrounded by
    the preprocessor conditionals
\begin{verbatim}
#ifndef _PNL_MATRIX_H
#define _PNL_MATRIX_H

...

#endif /* _PNL_MATRIX_H
\end{verbatim}
All the header files are protected by an \verb!extern "C"! declaration for
possible use with a C++ compiler.

  \item All function names are prefixed by \verb!pnl_! except those implementing
    complex number arithmetic which are named following the \textit{C99}
    complex library but using a capitalised first letter \verb!C!. \\
    For example, the addition of two complex numbers is performed by the
    function \verb!Cadd!.

  \item Function containing \verb!_create! in their names always return a
    pointer to an object created by one or several calls to dynamic
    allocation. Once these objects are not used, they must be freed by calling
    the same function but ending in \verb!_free!.
    A function \verb!pnl_foo_create_yyy! returns a \verb!PnlFoo *! object (note
    the ``\ptr'') and a function \verb!pnl_foo_bar_create_yyy! returns a
    \verb!PnlFooBar *! object (note the ``\ptr'').
    These objects must be freed by calling respectively \verb!pnl_foo_free! or
    \verb!pnl_foo_bar_free!.
    
  \item Every object must implement a \verb!pnl_xxx_new! function which returns
    a pointer to an empty object with all its elements properly set to $0$. This
    means that the objects returned by the \verb!pnl_xxx_new! functions can be
    used as output arguments for functions ending in \verb!_inplace! for
    instance. They are suitable for being resized. 

  \item Functions containing \verb!_wrap_! in their names always return an
    object, not a pointer to an object, and do not make any use of dynamic
    allocation. The returned object must not be freed. 
    For instance, a function \verb!pnl_foo_wrap_xxx! returns an object
    \verb!PnlFoo! and a function \verb!pnl_foo_bar_wrap_xxx! returns an object
    \verb!PnlFooBar! 
    \begin{verbatim}
    PnlVectComplex *v1;
    PnlVectComplex v2;
    v1 = pnl_vect_complex_create_from_complex (5, Complex(0., 1.));
    v2 = pnl_vect_complex_wrap_subvect (v1, 1, 2);

    ...

    pnl_vect_complex_free (&v1);
    \end{verbatim}
    The vector \verb!v1! is of size 5 and contains the pure imaginary number
    $i$. The vector \verb!v2! only provides a view to \verb!v1(1:1+2)!, which
    means that modifying \verb!v2! will also modify \verb!v1! and vice-versa
    because \verb!v1! shares part of its data with \verb!v2!. Note that only
    \verb!v1! must be freed and {\bf not} \verb!v2!.
  
  \item Functions ending in \verb!_init! do not create any object but only
    perform some internal initialisation.
  
  \item Hypermatrices, matrices and vectors are stored using a flat block of
    memory obtained by concatenating the matrix rows and C-style
    pointer-to-pointer arrays. Matrices are stored in row-major order, which
    means that the column index moves continuously.
    Note that this convention is not \textit{Blas \& Lapack} compliant since
    Fortran expects 2-dimensional arrays to be stored in a column-major order.

  \item Type names always begin with \verb!Pnl!, they do not contain underscores
    but instead we use capital letters to separate units in type names. \\
    Examples : \verb!PnlMat!, \verb!PnlMatComplex!.

  \item Object and function names are intimately linked : an object
    \verb!PnlFoo! is manipulated by functions starting in \verb!pnl_foo!, an
    object \verb!PnlFooBar! is manipulated by functions starting in
    \verb!pnl_foo_bar!. In table~\ref{pnltypes}, we summarise the types and their
    corresponding prefixes.

    \begin{figure}[h!]
      \centering\begin{tabular}{|l|l|}
      \hline
      Pnl types & Pnl prefix \\
      \hline
      PnlVect & pnl_vect \\
      PnlVectComplex & pnl_vect_complex \\
      PnlVectInt & pnl_vect_int \\
       &\\
      PnlMat & pnl_mat \\
      PnlMatComplex & pnl_mat_complex \\
      PnlMatInt & pnl_mat_int \\
      & \\
      PnlHmat & pnl_hmat \\
      PnlHmatComplex & pnl_hmat_complex \\
      PnlHmatInt & pnl_hmat_int \\
      & \\
      PnlTridiagMat & pnl_tridiag_mat \\
      PnlBandMat & pnl_band_mat \\
      & \\
      PnlBasis & pnl_basis \\
      & \\
      PnlCgSolver & pnl_cg_solver \\
      PnlBicgSolver & pnl_bicg_solver \\
      PnlGmresSolver & pnl_gmres_solver \\
      \hline
    \end{tabular}
    \caption{Pnl types}
    \label{pnltypes}
  \end{figure}

  \item All macro names begin with \verb!PNL_! and are capitalised.

  \item Differences between \textbf{copy} and \textbf{clone} methods.
    The \verb!copy! methods take a single argument and return a pointer to an object
    of the same type which is an independent copy of its argument. 
    Example:
    \begin{verbatim}
    PnlVect *v1, *v2;
    v1 = pnl_vect_create_from_double (5, 2.5);
    v2 = pnl_vect_copy (v1);
    \end{verbatim}
    \verb!v1! and \verb!v2! are two vectors of size 5 with all their elements
    equal to 2.5. Note that \verb!v2! {\bf must not} have been created by a call
    to \verb!pnl_vect_create_xxx! because otherwise it will cause a memory leak.
    \verb!v1! and \verb!v2! are independent in the sense that a modification to
    one of them does not affect the other.

    The \verb!clone! methods take two arguments and fill in the first one with the
    second one. 
    Example:
    \begin{verbatim}
    PnlVect *v1, *v2;
    v1 = pnl_vect_create_from_double (5, 2.5);
    v2 = pnl_vect_new ();
    pnl_vect_clone (v2, v1);
    \end{verbatim}
    \verb!v1! and \verb!v2! are two vectors of size 5 with all their elements
    equal to 2.5. Note that \verb!v2! {\bf must} have been created by a call to
    \verb!pnl_vect_new! because otherwise the function
    \verb!pnl_vect_clone!  will crash.  \verb!v1! and \verb!v2! are independent
    in the sense that a modification to one of them does not modify the other.


  \item All objects are measured using integers \verb!int! and not
    \verb!size_t!. Hence, iterations over vectors, matrices, \dots should use an
    index of type \verb!int!.
\end{itemize}




\input{mathematical_functions.tex}
\input{linear_algebra.tex}
\input{probabilistic_methods.tex}
\input{deterministic_methods.tex}

\printindex

\end{document}
